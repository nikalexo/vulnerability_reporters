import traceback
import re, requests, time
from datetime import datetime
from bs4 import BeautifulSoup

# Prints info of bug2commits to see changes
def print_changes(bug2commits, updates=None):
    number_bugs_with_commits = 0
    for bug in bug2commits.keys():
        if bug2commits[bug] != []:
            number_bugs_with_commits += 1
    print("Number of bugs with at least one commit:", number_bugs_with_commits)
    print("Number of bugs with no commit:", (len(bug2commits) - number_bugs_with_commits))
    if updates != None:
        print("Number of new insertions:", updates)

# Search for contents in comments of bugs in collection based on regular expression 
# Additionally, it can be indicated if the content is a commit and it should be inserted into bug2commits
def parse_comments(bug2contents, collection, expr, insert_in_bug2commits=False):
    updates = 0
    for document in collection.find({}):     # parse each bug
        bug = str(document['id'])
        contents = []                           # all found contents for one bug
        if document["comments"] != None:        # field should not be None
            for comment in document["comments"]:    # parse all comments of one bug
                text = comment['text']          # get text of comment data
                try:
                    m = re.findall(expr, text)  # find occurrencies of regular expression
                    if len(m) > 0:
                        content = ""
                        for result in m:
                            if type(result) == tuple:   # check if result tuple 
                                result = result[0]      # then only first element in tuple is relevant
                            for i in range(len(result)-1, -1, -1):  # iterate from end to start of result
                                if result[i].isdigit() or result[i] in ["a", "b", "c", "d", "e", "f"]:
                                    content = result[i] + content   # add current character
                                else:
                                    break
                            contents.append(content)
                            #print(content, bug)
                            updates += 1
                            content = ""
                except:
                    print("Something went wrong!")
                    traceback.print_exc()
        if insert_in_bug2commits:
            for content in contents:
                add_commit_to_bug(bug2contents, bug, content)
        else:
            if not bug in bug2contents.keys():
                bug2contents[bug] = []
            for content in contents:
                if content not in bug2contents[bug]:
                    bug2contents[bug].append(content)
    return updates

# Matches mercurial repo hashes to commits of the github repo
def match_hashes_commits_mercurial(bug2revs, bug2commits, commits, log):
    updates = 0
    hash2message = dict()
    i = 0
    counter = 0
    # print(len(log))

    for bug in bug2revs.keys():
        counter += 1
        #print("Matching hashes for bug " + str(counter) + "...")

        for r in bug2revs[bug]:
            already_fetched = False
            for key in hash2message.keys():
                if key[1] == r:
                    already_fetched = True
                    hash2message[(bug, r)] = hash2message[key]
                    break
            if not already_fetched:
                for merc_commit in log:
                    if r == merc_commit[0].decode("utf-8") or r == merc_commit[1].decode("utf-8")  or r == merc_commit[1].decode("utf-8")[:12]:
                        hash2message[(bug, r)] = merc_commit[5].decode("utf-8")
        
    for commit in commits:
        for key in hash2message.keys():
            message = hash2message[key]
            m  = str(message)
            if len(m) > 20 and (not ("merge" in m.lower() and "to" in m.lower())) and m in str(commit.message):
                bug = key[0]
                updates += add_commit_to_bug(bug2commits, str(bug), commit.hexsha)
                
# Inserts extra found commits (see extra_....py scripts)
def insert_extra(bug2commit, bug2commit_temp):
    updates = 0
    for bug in bug2commit_temp.keys():
        if bug in bug2commit.keys():
            before = len(bug2commit[bug])
            bug2commit[bug].extend(list(set(bug2commit_temp[bug]) - set(bug2commit[bug])))
            after = len(bug2commit[bug])
            updates += (after - before)
    return updates

# Add bug-ids as keys in the given dictionary. Set value to empty list
def add_bugs_to_dict(bug_dict, collection):
    for document in collection.find({}):
        bug_dict[str(document['id'])] = []

# Add creation time and modification time as tuple for the value of given dictionary
def add_date_to_bug(bug2date, collection):
    for document in collection.find({}):
        try:
            bug2date[str(document['id'])] = (document['creation_time'], document['last_change_time'])  # e.g. 2020-04-14T15:05:15Z
        except:
            traceback.print_exc()
            print("Could not find creation time of bug:", document['id'])
            bug2date[str(document['id'])] = (None, None)

# Extracts all mentioned bugs in a commit message based on a given regular expression.
def extract_bugs_commit(message, regular_expr):
    try:
        message.replace("\n", " ")
      
        bug_ids = []
        m = re.findall(regular_expr, message)
        if len(m) > 0:
            if "buglist" in regular_expr:   # special case for regular expr with buglist inside -> bugzilla url
                for e in m:                 # for each occurrency of the url in reg expr (all tuples)
                    bug_refs=re.split('\%2C', e[0])     # split first element in tuple which contains the complete url with all bugs
                    for bug in bug_refs:
                        bug_id = ""
                        # for each split get only ids
                        for i in range(len(bug)-1, -1, -1):
                            if bug[i].isdigit():
                                bug_id = bug[i] + bug_id
                            else:
                                break
                        bug_ids.append(bug_id)
            else:
                for bug in m:
                    bug_id = ""
                    if type(bug) == tuple:
                        bug = bug[0]
                    # for each split get only ids
                    for i in range(len(bug)-1, -1, -1):
                        if bug[i].isdigit():
                            bug_id = bug[i] + bug_id
                        else:
                            break
                    bug_ids.append(bug_id)
            return bug_ids
        else:
            return None
    except:
        try:
            print("Something went wrong: " + commit.hexsha + commit.message)
            return None
        except:
            print("Something went wrong!")
            traceback.print_exc()
            return None

# Extracts all mentioned bugs in a commit message based on a given regular expression.
# Additionaly, it is possible to check the time difference of bug creation date/modification date and include only 
# these found bug-ids whose minimum time difference is smaller than 'max_time_diff'
def extract_bugs_commits(bug2commits, bug2time, commits, regular_expr, check_time=False, max_time_diff=0):
    updates = 0
    for commit in commits:
        try:
            message = commit.message
            message = message.lower()
            bugs = extract_bugs_commit(message, regular_expr)
            if bugs != None:
                for bug in bugs:
                    if check_time:
                        if bug in bug2time.keys():
                            diff_ok = compute_min_diff_time(bug2time[bug], commit.committed_date, max_time_diff)
                            if diff_ok:
                                updates += add_commit_to_bug(bug2commits, bug, commit.hexsha)
                            else:
                                print("Minimum time difference of commit '" + commit.hexsha + "' (" + str(commit.committed_date) + ") and bug '" + str(bug) + "' (" + str(bug2time[bug]) + ") is greater than " + str(max_time_diff) + "!")
                    else:
                        updates += add_commit_to_bug(bug2commits, bug, commit.hexsha)
        except:
            print("Error")
            traceback.print_exc()
    return updates

# Adds a commit to a bug-id in the given dictionary
# Additionaly, it is possible to insert new found bug-ids which are not already in the dictionary 
def add_commit_to_bug(bug2commits, bug_id, commit, insert_new_bug=False):
    if bug_id != None:
        if str(bug_id) in bug2commits.keys(): # ATTENTION only bugs which are already bug2commits are considered
            if not str(commit) in bug2commits[str(bug_id)]:
                # print(commit, bug_id)
                bug2commits[bug_id].append(str(commit))
                return 1
        elif insert_new_bug:   # Add bugs even if they are not in bug2commit.keys()
           bug2commits[bug_id] = [str(commit)]
           return 1
    return 0

# Computes the minimum time difference between commit and bug
def compute_min_diff_time(times_bug, committed_date, max_time_diff):
    # e.g. "2018-04-10T04:00:00.000Z"
    try:
        if times_bug[0] == None or times_bug[1] == None:
            return True
        year = int(times_bug[0][:4])
        month = int(times_bug[0][5:7])
        day = int(times_bug[0][8:10])
        timestamp1_1 = datetime(year, month, day).strftime('%s')
        year = int(times_bug[1][:4])
        month = int(times_bug[1][5:7])
        day = int(times_bug[1][8:10])
        timestamp1_2 = datetime(year, month, day).strftime('%s')
        timestamp2 = committed_date
        if float(timestamp2) >= float(timestamp1_1) and float(timestamp2) <= float(timestamp1_2):
            return True
        diff = min(abs((float(timestamp1_1)-float(timestamp2))/(60*60*24)), abs((float(timestamp1_2)-float(timestamp2))/(60*60*24)))
        return diff <= max_time_diff
    except:
        print(times_bug)
        traceback.print_exc()
        return True